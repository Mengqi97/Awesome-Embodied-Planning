# **【2023 ICRA】Code as Policies-Language Model Programs for Embodied Control**

​    官方主页： https://code-as-policies.github.io/

## **1、文章概述**

- 任务：将自然语言指令转换为可执行的机器人控制代码

- 

  方法“代码即策略”（Code as Policies，CaP）核心是利用大型语言模型（LLM）将自然语言指令转换为可执行的机器人代码。方法可以分为高层级和低层级两个方面。

  - 高层级：
    - 用户交互： 用户通过自然语言指令与机器人进行交互，例如“将积木堆叠在空碗里”。
    - 指令解析： LLM 将自然语言指令解析为高级代码逻辑，例如确定哪些物体需要移动，目标位置在哪里等等。
    - 策略代码生成： LLM 生成调用底层 API 的 Python 代码，实现具体操作。
    - 代码执行： 系统执行生成的代码，控制机器人的动作。
  - 低层级：
    - 感知 API：  提供对机器人感知能力的访问接口，例如物体检测、位置识别、颜色识别等。LLM 可以调用这些 API 获取环境信息，例如获取某个物体的名称、位置、颜色等。
    - 控制 API：  提供对机器人控制能力的访问接口，例如移动、抓取、放置等。LLM 可以调用这些 API 控制机器人的具体动作，例如将某个物体移动到指定位置。
      代码即策略方法的关键在于将高级指令解析与底层 API 调用结合起来，实现端到端的机器人控制

![](https://github.com/Mengqi97/Awesome-Embodied-Planning/blob/main/papernote_fig/cap/sum1.png)   

<!--给定示例（通过少量镜头提示），机器人可以使用编写代码的大型语言模型（LLM）将自然语言命令转换为机器人策略代码，该代码处理感知输出，参数化控制原语，递归生成未定义函数的代码，并推广到新任务。-->

## **2、方法细节**

​	先生成完整的可执行代码，再让机器人一次性执行该代码

### 2.1 低层级代码生成示例

- 使用第三方库：LLM 可以利用第三方库（例如 NumPy）进行空间推理和计算，例如计算点之间的距离，判断物体之间的位置关系等。
- 调用自定义函数：可以通过提示工程，让 LLM 学习调用自定义的函数，例如定义一个函数来获取某个物体的颜色，然后在代码中调用这个函数。

### 2.2 高层级代码生成示例

- 控制流：LLM 可以使用控制结构（例如 if-else 语句和循环语句）来实现复杂的控制逻辑，例如当满足某个条件时才执行某个动作。

- 函数嵌套：LLM 可以嵌套调用多个函数，实现多步骤的复杂任务。

- 分层代码生成： 可以提示 LLM 递归地定义新的函数，从而生成更复杂和结构化的代码。例如，可以先定义一个函数来识别某个物体，然后定义另一个函数来将该物体移动到指定位置。

  通过分层代码生成，可以将复杂的任务分解成多个简单的子任务，提高代码的可读性和可维护性。
  总而言之，CaP 方法为机器人控制提供了一种新的思路，通过利用 LLM 的强大能力，可以更灵活地控制机器人完成各种任务。

## **3、实验设计**

这篇文章提到了用于测试的两个代码生成数据集：

- 评价指标：通过率，**即生成的代码通过人工编写的单元测试的百分比**。
- RoboCodeGen: 这是一个由文章作者团队创建的全新数据集，专门用于测试与机器人相关的代码生成能力。 
  - 它包含 37 个函数生成问题，涵盖空间推理、几何推理和控制等方面，例如寻找最接近一组点的点、检查一个边界框是否包含在另一个边界框中、PD 控制等。
  - 数据集鼓励使用第三方库（例如 NumPy）。
  - 提供的函数头没有文档字符串或显式类型提示，因此 LLM 需要推断和使用通用约定。
  - 允许使用尚未定义的函数，可以使用分层代码生成创建。
- HumanEval : 这是一个标准的代码生成基准测试，包含通用的代码生成问题。文章使用它来评估分层代码生成方法在通用代码生成问题上的效果。

![](https://github.com/Mengqi97/Awesome-Embodied-Planning/blob/main/papernote_fig/cap/sum2.png)

除了这两个数据集，文章还进行了其他实验，例如使用 CaP 方法在模拟环境和真实机器人上完成各种任务，并在附录中提供了更多示例和结果。
